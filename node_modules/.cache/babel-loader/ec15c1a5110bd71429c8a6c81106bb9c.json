{"ast":null,"code":"/*!\r\n * media-typer\r\n * Copyright(c) 2014 Douglas Christopher Wilson\r\n * MIT Licensed\r\n */\n\n/**\r\n * RegExp to match *( \";\" parameter ) in RFC 2616 sec 3.7\r\n *\r\n * parameter     = token \"=\" ( token | quoted-string )\r\n * token         = 1*<any CHAR except CTLs or separators>\r\n * separators    = \"(\" | \")\" | \"<\" | \">\" | \"@\"\r\n *               | \",\" | \";\" | \":\" | \"\\\" | <\">\r\n *               | \"/\" | \"[\" | \"]\" | \"?\" | \"=\"\r\n *               | \"{\" | \"}\" | SP | HT\r\n * quoted-string = ( <\"> *(qdtext | quoted-pair ) <\"> )\r\n * qdtext        = <any TEXT except <\">>\r\n * quoted-pair   = \"\\\" CHAR\r\n * CHAR          = <any US-ASCII character (octets 0 - 127)>\r\n * TEXT          = <any OCTET except CTLs, but including LWS>\r\n * LWS           = [CRLF] 1*( SP | HT )\r\n * CRLF          = CR LF\r\n * CR            = <US-ASCII CR, carriage return (13)>\r\n * LF            = <US-ASCII LF, linefeed (10)>\r\n * SP            = <US-ASCII SP, space (32)>\r\n * SHT           = <US-ASCII HT, horizontal-tab (9)>\r\n * CTL           = <any US-ASCII control character (octets 0 - 31) and DEL (127)>\r\n * OCTET         = <any 8-bit sequence of data>\r\n */\nvar paramRegExp = /; *([!#$%&'\\*\\+\\-\\.0-9A-Z\\^_`a-z\\|~]+) *= *(\"(?:[ !\\u0023-\\u005b\\u005d-\\u007e\\u0080-\\u00ff]|\\\\[\\u0020-\\u007e])*\"|[!#$%&'\\*\\+\\-\\.0-9A-Z\\^_`a-z\\|~]+) */g;\nvar textRegExp = /^[\\u0020-\\u007e\\u0080-\\u00ff]+$/;\nvar tokenRegExp = /^[!#$%&'\\*\\+\\-\\.0-9A-Z\\^_`a-z\\|~]+$/;\n\n/**\r\n * RegExp to match quoted-pair in RFC 2616\r\n *\r\n * quoted-pair = \"\\\" CHAR\r\n * CHAR        = <any US-ASCII character (octets 0 - 127)>\r\n */\nvar qescRegExp = /\\\\([\\u0000-\\u007f])/g;\n\n/**\r\n * RegExp to match chars that must be quoted-pair in RFC 2616\r\n */\nvar quoteRegExp = /([\\\\\"])/g;\n\n/**\r\n * RegExp to match type in RFC 6838\r\n *\r\n * type-name = restricted-name\r\n * subtype-name = restricted-name\r\n * restricted-name = restricted-name-first *126restricted-name-chars\r\n * restricted-name-first  = ALPHA / DIGIT\r\n * restricted-name-chars  = ALPHA / DIGIT / \"!\" / \"#\" /\r\n *                          \"$\" / \"&\" / \"-\" / \"^\" / \"_\"\r\n * restricted-name-chars =/ \".\" ; Characters before first dot always\r\n *                              ; specify a facet name\r\n * restricted-name-chars =/ \"+\" ; Characters after last plus always\r\n *                              ; specify a structured syntax suffix\r\n * ALPHA =  %x41-5A / %x61-7A   ; A-Z / a-z\r\n * DIGIT =  %x30-39             ; 0-9\r\n */\nvar subtypeNameRegExp = /^[A-Za-z0-9][A-Za-z0-9!#$&^_.-]{0,126}$/;\nvar typeNameRegExp = /^[A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126}$/;\nvar typeRegExp = /^ *([A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126})\\/([A-Za-z0-9][A-Za-z0-9!#$&^_.+-]{0,126}) *$/;\n\n/**\r\n * Module exports.\r\n */\n\nexports.format = format;\nexports.parse = parse;\n\n/**\r\n * Format object to media type.\r\n *\r\n * @param {object} obj\r\n * @return {string}\r\n * @api public\r\n */\n\nfunction format(obj) {\n  if (!obj || typeof obj !== 'object') {\n    throw new TypeError('argument obj is required');\n  }\n  var parameters = obj.parameters;\n  var subtype = obj.subtype;\n  var suffix = obj.suffix;\n  var type = obj.type;\n  if (!type || !typeNameRegExp.test(type)) {\n    throw new TypeError('invalid type');\n  }\n  if (!subtype || !subtypeNameRegExp.test(subtype)) {\n    throw new TypeError('invalid subtype');\n  }\n\n  // format as type/subtype\n  var string = type + '/' + subtype;\n\n  // append +suffix\n  if (suffix) {\n    if (!typeNameRegExp.test(suffix)) {\n      throw new TypeError('invalid suffix');\n    }\n    string += '+' + suffix;\n  }\n\n  // append parameters\n  if (parameters && typeof parameters === 'object') {\n    var param;\n    var params = Object.keys(parameters).sort();\n    for (var i = 0; i < params.length; i++) {\n      param = params[i];\n      if (!tokenRegExp.test(param)) {\n        throw new TypeError('invalid parameter name');\n      }\n      string += '; ' + param + '=' + qstring(parameters[param]);\n    }\n  }\n  return string;\n}\n\n/**\r\n * Parse media type to object.\r\n *\r\n * @param {string|object} string\r\n * @return {Object}\r\n * @api public\r\n */\n\nfunction parse(string) {\n  if (!string) {\n    throw new TypeError('argument string is required');\n  }\n\n  // support req/res-like objects as argument\n  if (typeof string === 'object') {\n    string = getcontenttype(string);\n  }\n  if (typeof string !== 'string') {\n    throw new TypeError('argument string is required to be a string');\n  }\n  var index = string.indexOf(';');\n  var type = index !== -1 ? string.substr(0, index) : string;\n  var key;\n  var match;\n  var obj = splitType(type);\n  var params = {};\n  var value;\n  paramRegExp.lastIndex = index;\n  while (match = paramRegExp.exec(string)) {\n    if (match.index !== index) {\n      throw new TypeError('invalid parameter format');\n    }\n    index += match[0].length;\n    key = match[1].toLowerCase();\n    value = match[2];\n    if (value[0] === '\"') {\n      // remove quotes and escapes\n      value = value.substr(1, value.length - 2).replace(qescRegExp, '$1');\n    }\n    params[key] = value;\n  }\n  if (index !== -1 && index !== string.length) {\n    throw new TypeError('invalid parameter format');\n  }\n  obj.parameters = params;\n  return obj;\n}\n\n/**\r\n * Get content-type from req/res objects.\r\n *\r\n * @param {object}\r\n * @return {Object}\r\n * @api private\r\n */\n\nfunction getcontenttype(obj) {\n  if (typeof obj.getHeader === 'function') {\n    // res-like\n    return obj.getHeader('content-type');\n  }\n  if (typeof obj.headers === 'object') {\n    // req-like\n    return obj.headers && obj.headers['content-type'];\n  }\n}\n\n/**\r\n * Quote a string if necessary.\r\n *\r\n * @param {string} val\r\n * @return {string}\r\n * @api private\r\n */\n\nfunction qstring(val) {\n  var str = String(val);\n\n  // no need to quote tokens\n  if (tokenRegExp.test(str)) {\n    return str;\n  }\n  if (str.length > 0 && !textRegExp.test(str)) {\n    throw new TypeError('invalid parameter value');\n  }\n  return '\"' + str.replace(quoteRegExp, '\\\\$1') + '\"';\n}\n\n/**\r\n * Simply \"type/subtype+siffx\" into parts.\r\n *\r\n * @param {string} string\r\n * @return {Object}\r\n * @api private\r\n */\n\nfunction splitType(string) {\n  var match = typeRegExp.exec(string.toLowerCase());\n  if (!match) {\n    throw new TypeError('invalid media type');\n  }\n  var type = match[1];\n  var subtype = match[2];\n  var suffix;\n\n  // suffix after last +\n  var index = subtype.lastIndexOf('+');\n  if (index !== -1) {\n    suffix = subtype.substr(index + 1);\n    subtype = subtype.substr(0, index);\n  }\n  var obj = {\n    type: type,\n    subtype: subtype,\n    suffix: suffix\n  };\n  return obj;\n}","map":null,"metadata":{},"sourceType":"script"}