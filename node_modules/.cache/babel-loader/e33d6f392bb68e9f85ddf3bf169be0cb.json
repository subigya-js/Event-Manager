{"ast":null,"code":"/*!\r\n * forwarded\r\n * Copyright(c) 2014-2017 Douglas Christopher Wilson\r\n * MIT Licensed\r\n */\n\n'use strict';\n\n/**\r\n * Module exports.\r\n * @public\r\n */\nmodule.exports = forwarded;\n\n/**\r\n * Get all addresses in the request, using the `X-Forwarded-For` header.\r\n *\r\n * @param {object} req\r\n * @return {array}\r\n * @public\r\n */\n\nfunction forwarded(req) {\n  if (!req) {\n    throw new TypeError('argument req is required');\n  }\n\n  // simple header parsing\n  var proxyAddrs = parse(req.headers['x-forwarded-for'] || '');\n  var socketAddr = getSocketAddr(req);\n  var addrs = [socketAddr].concat(proxyAddrs);\n\n  // return all addresses\n  return addrs;\n}\n\n/**\r\n * Get the socket address for a request.\r\n *\r\n * @param {object} req\r\n * @return {string}\r\n * @private\r\n */\n\nfunction getSocketAddr(req) {\n  return req.socket ? req.socket.remoteAddress : req.connection.remoteAddress;\n}\n\n/**\r\n * Parse the X-Forwarded-For header.\r\n *\r\n * @param {string} header\r\n * @private\r\n */\n\nfunction parse(header) {\n  var end = header.length;\n  var list = [];\n  var start = header.length;\n\n  // gather addresses, backwards\n  for (var i = header.length - 1; i >= 0; i--) {\n    switch (header.charCodeAt(i)) {\n      case 0x20:\n        /*   */\n        if (start === end) {\n          start = end = i;\n        }\n        break;\n      case 0x2c:\n        /* , */\n        if (start !== end) {\n          list.push(header.substring(start, end));\n        }\n        start = end = i;\n        break;\n      default:\n        start = i;\n        break;\n    }\n  }\n\n  // final address\n  if (start !== end) {\n    list.push(header.substring(start, end));\n  }\n  return list;\n}","map":null,"metadata":{},"sourceType":"script"}