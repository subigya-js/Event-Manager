{"ast":null,"code":"/*!\r\n * proxy-addr\r\n * Copyright(c) 2014-2016 Douglas Christopher Wilson\r\n * MIT Licensed\r\n */\n\n'use strict';\n\n/**\r\n * Module exports.\r\n * @public\r\n */\nmodule.exports = proxyaddr;\nmodule.exports.all = alladdrs;\nmodule.exports.compile = compile;\n\n/**\r\n * Module dependencies.\r\n * @private\r\n */\n\nvar forwarded = require('forwarded');\nvar ipaddr = require('ipaddr.js');\n\n/**\r\n * Variables.\r\n * @private\r\n */\n\nvar DIGIT_REGEXP = /^[0-9]+$/;\nvar isip = ipaddr.isValid;\nvar parseip = ipaddr.parse;\n\n/**\r\n * Pre-defined IP ranges.\r\n * @private\r\n */\n\nvar IP_RANGES = {\n  linklocal: ['169.254.0.0/16', 'fe80::/10'],\n  loopback: ['127.0.0.1/8', '::1/128'],\n  uniquelocal: ['10.0.0.0/8', '172.16.0.0/12', '192.168.0.0/16', 'fc00::/7']\n};\n\n/**\r\n * Get all addresses in the request, optionally stopping\r\n * at the first untrusted.\r\n *\r\n * @param {Object} request\r\n * @param {Function|Array|String} [trust]\r\n * @public\r\n */\n\nfunction alladdrs(req, trust) {\n  // get addresses\n  var addrs = forwarded(req);\n  if (!trust) {\n    // Return all addresses\n    return addrs;\n  }\n  if (typeof trust !== 'function') {\n    trust = compile(trust);\n  }\n  for (var i = 0; i < addrs.length - 1; i++) {\n    if (trust(addrs[i], i)) continue;\n    addrs.length = i + 1;\n  }\n  return addrs;\n}\n\n/**\r\n * Compile argument into trust function.\r\n *\r\n * @param {Array|String} val\r\n * @private\r\n */\n\nfunction compile(val) {\n  if (!val) {\n    throw new TypeError('argument is required');\n  }\n  var trust;\n  if (typeof val === 'string') {\n    trust = [val];\n  } else if (Array.isArray(val)) {\n    trust = val.slice();\n  } else {\n    throw new TypeError('unsupported trust argument');\n  }\n  for (var i = 0; i < trust.length; i++) {\n    val = trust[i];\n    if (!Object.prototype.hasOwnProperty.call(IP_RANGES, val)) {\n      continue;\n    }\n\n    // Splice in pre-defined range\n    val = IP_RANGES[val];\n    trust.splice.apply(trust, [i, 1].concat(val));\n    i += val.length - 1;\n  }\n  return compileTrust(compileRangeSubnets(trust));\n}\n\n/**\r\n * Compile `arr` elements into range subnets.\r\n *\r\n * @param {Array} arr\r\n * @private\r\n */\n\nfunction compileRangeSubnets(arr) {\n  var rangeSubnets = new Array(arr.length);\n  for (var i = 0; i < arr.length; i++) {\n    rangeSubnets[i] = parseipNotation(arr[i]);\n  }\n  return rangeSubnets;\n}\n\n/**\r\n * Compile range subnet array into trust function.\r\n *\r\n * @param {Array} rangeSubnets\r\n * @private\r\n */\n\nfunction compileTrust(rangeSubnets) {\n  // Return optimized function based on length\n  var len = rangeSubnets.length;\n  return len === 0 ? trustNone : len === 1 ? trustSingle(rangeSubnets[0]) : trustMulti(rangeSubnets);\n}\n\n/**\r\n * Parse IP notation string into range subnet.\r\n *\r\n * @param {String} note\r\n * @private\r\n */\n\nfunction parseipNotation(note) {\n  var pos = note.lastIndexOf('/');\n  var str = pos !== -1 ? note.substring(0, pos) : note;\n  if (!isip(str)) {\n    throw new TypeError('invalid IP address: ' + str);\n  }\n  var ip = parseip(str);\n  if (pos === -1 && ip.kind() === 'ipv6' && ip.isIPv4MappedAddress()) {\n    // Store as IPv4\n    ip = ip.toIPv4Address();\n  }\n  var max = ip.kind() === 'ipv6' ? 128 : 32;\n  var range = pos !== -1 ? note.substring(pos + 1, note.length) : null;\n  if (range === null) {\n    range = max;\n  } else if (DIGIT_REGEXP.test(range)) {\n    range = parseInt(range, 10);\n  } else if (ip.kind() === 'ipv4' && isip(range)) {\n    range = parseNetmask(range);\n  } else {\n    range = null;\n  }\n  if (range <= 0 || range > max) {\n    throw new TypeError('invalid range on address: ' + note);\n  }\n  return [ip, range];\n}\n\n/**\r\n * Parse netmask string into CIDR range.\r\n *\r\n * @param {String} netmask\r\n * @private\r\n */\n\nfunction parseNetmask(netmask) {\n  var ip = parseip(netmask);\n  var kind = ip.kind();\n  return kind === 'ipv4' ? ip.prefixLengthFromSubnetMask() : null;\n}\n\n/**\r\n * Determine address of proxied request.\r\n *\r\n * @param {Object} request\r\n * @param {Function|Array|String} trust\r\n * @public\r\n */\n\nfunction proxyaddr(req, trust) {\n  if (!req) {\n    throw new TypeError('req argument is required');\n  }\n  if (!trust) {\n    throw new TypeError('trust argument is required');\n  }\n  var addrs = alladdrs(req, trust);\n  var addr = addrs[addrs.length - 1];\n  return addr;\n}\n\n/**\r\n * Static trust function to trust nothing.\r\n *\r\n * @private\r\n */\n\nfunction trustNone() {\n  return false;\n}\n\n/**\r\n * Compile trust function for multiple subnets.\r\n *\r\n * @param {Array} subnets\r\n * @private\r\n */\n\nfunction trustMulti(subnets) {\n  return function trust(addr) {\n    if (!isip(addr)) return false;\n    var ip = parseip(addr);\n    var ipconv;\n    var kind = ip.kind();\n    for (var i = 0; i < subnets.length; i++) {\n      var subnet = subnets[i];\n      var subnetip = subnet[0];\n      var subnetkind = subnetip.kind();\n      var subnetrange = subnet[1];\n      var trusted = ip;\n      if (kind !== subnetkind) {\n        if (subnetkind === 'ipv4' && !ip.isIPv4MappedAddress()) {\n          // Incompatible IP addresses\n          continue;\n        }\n        if (!ipconv) {\n          // Convert IP to match subnet IP kind\n          ipconv = subnetkind === 'ipv4' ? ip.toIPv4Address() : ip.toIPv4MappedAddress();\n        }\n        trusted = ipconv;\n      }\n      if (trusted.match(subnetip, subnetrange)) {\n        return true;\n      }\n    }\n    return false;\n  };\n}\n\n/**\r\n * Compile trust function for single subnet.\r\n *\r\n * @param {Object} subnet\r\n * @private\r\n */\n\nfunction trustSingle(subnet) {\n  var subnetip = subnet[0];\n  var subnetkind = subnetip.kind();\n  var subnetisipv4 = subnetkind === 'ipv4';\n  var subnetrange = subnet[1];\n  return function trust(addr) {\n    if (!isip(addr)) return false;\n    var ip = parseip(addr);\n    var kind = ip.kind();\n    if (kind !== subnetkind) {\n      if (subnetisipv4 && !ip.isIPv4MappedAddress()) {\n        // Incompatible IP addresses\n        return false;\n      }\n\n      // Convert IP to match subnet IP kind\n      ip = subnetisipv4 ? ip.toIPv4Address() : ip.toIPv4MappedAddress();\n    }\n    return ip.match(subnetip, subnetrange);\n  };\n}","map":null,"metadata":{},"sourceType":"script"}