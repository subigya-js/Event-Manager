{"ast":null,"code":"/*!\r\n * body-parser\r\n * Copyright(c) 2014 Jonathan Ong\r\n * Copyright(c) 2014-2015 Douglas Christopher Wilson\r\n * MIT Licensed\r\n */\n\n'use strict';\n\n/**\r\n * Module dependencies.\r\n * @private\r\n */\nvar bytes = require('bytes');\nvar contentType = require('content-type');\nvar createError = require('http-errors');\nvar debug = require('debug')('body-parser:json');\nvar read = require('../read');\nvar typeis = require('type-is');\n\n/**\r\n * Module exports.\r\n */\n\nmodule.exports = json;\n\n/**\r\n * RegExp to match the first non-space in a string.\r\n *\r\n * Allowed whitespace is defined in RFC 7159:\r\n *\r\n *    ws = *(\r\n *            %x20 /              ; Space\r\n *            %x09 /              ; Horizontal tab\r\n *            %x0A /              ; Line feed or New line\r\n *            %x0D )              ; Carriage return\r\n */\n\nvar FIRST_CHAR_REGEXP = /^[\\x20\\x09\\x0a\\x0d]*([^\\x20\\x09\\x0a\\x0d])/; // eslint-disable-line no-control-regex\n\n/**\r\n * Create a middleware to parse JSON bodies.\r\n *\r\n * @param {object} [options]\r\n * @return {function}\r\n * @public\r\n */\n\nfunction json(options) {\n  var opts = options || {};\n  var limit = typeof opts.limit !== 'number' ? bytes.parse(opts.limit || '100kb') : opts.limit;\n  var inflate = opts.inflate !== false;\n  var reviver = opts.reviver;\n  var strict = opts.strict !== false;\n  var type = opts.type || 'application/json';\n  var verify = opts.verify || false;\n  if (verify !== false && typeof verify !== 'function') {\n    throw new TypeError('option verify must be function');\n  }\n\n  // create the appropriate type checking function\n  var shouldParse = typeof type !== 'function' ? typeChecker(type) : type;\n  function parse(body) {\n    if (body.length === 0) {\n      // special-case empty json body, as it's a common client-side mistake\n      // TODO: maybe make this configurable or part of \"strict\" option\n      return {};\n    }\n    if (strict) {\n      var first = firstchar(body);\n      if (first !== '{' && first !== '[') {\n        debug('strict violation');\n        throw createStrictSyntaxError(body, first);\n      }\n    }\n    try {\n      debug('parse json');\n      return JSON.parse(body, reviver);\n    } catch (e) {\n      throw normalizeJsonSyntaxError(e, {\n        message: e.message,\n        stack: e.stack\n      });\n    }\n  }\n  return function jsonParser(req, res, next) {\n    if (req._body) {\n      debug('body already parsed');\n      next();\n      return;\n    }\n    req.body = req.body || {};\n\n    // skip requests without bodies\n    if (!typeis.hasBody(req)) {\n      debug('skip empty body');\n      next();\n      return;\n    }\n    debug('content-type %j', req.headers['content-type']);\n\n    // determine if request should be parsed\n    if (!shouldParse(req)) {\n      debug('skip parsing');\n      next();\n      return;\n    }\n\n    // assert charset per RFC 7159 sec 8.1\n    var charset = getCharset(req) || 'utf-8';\n    if (charset.slice(0, 4) !== 'utf-') {\n      debug('invalid charset');\n      next(createError(415, 'unsupported charset \"' + charset.toUpperCase() + '\"', {\n        charset: charset,\n        type: 'charset.unsupported'\n      }));\n      return;\n    }\n\n    // read\n    read(req, res, next, parse, debug, {\n      encoding: charset,\n      inflate: inflate,\n      limit: limit,\n      verify: verify\n    });\n  };\n}\n\n/**\r\n * Create strict violation syntax error matching native error.\r\n *\r\n * @param {string} str\r\n * @param {string} char\r\n * @return {Error}\r\n * @private\r\n */\n\nfunction createStrictSyntaxError(str, char) {\n  var index = str.indexOf(char);\n  var partial = index !== -1 ? str.substring(0, index) + '#' : '';\n  try {\n    JSON.parse(partial); /* istanbul ignore next */\n    throw new SyntaxError('strict violation');\n  } catch (e) {\n    return normalizeJsonSyntaxError(e, {\n      message: e.message.replace('#', char),\n      stack: e.stack\n    });\n  }\n}\n\n/**\r\n * Get the first non-whitespace character in a string.\r\n *\r\n * @param {string} str\r\n * @return {function}\r\n * @private\r\n */\n\nfunction firstchar(str) {\n  var match = FIRST_CHAR_REGEXP.exec(str);\n  return match ? match[1] : undefined;\n}\n\n/**\r\n * Get the charset of a request.\r\n *\r\n * @param {object} req\r\n * @api private\r\n */\n\nfunction getCharset(req) {\n  try {\n    return (contentType.parse(req).parameters.charset || '').toLowerCase();\n  } catch (e) {\n    return undefined;\n  }\n}\n\n/**\r\n * Normalize a SyntaxError for JSON.parse.\r\n *\r\n * @param {SyntaxError} error\r\n * @param {object} obj\r\n * @return {SyntaxError}\r\n */\n\nfunction normalizeJsonSyntaxError(error, obj) {\n  var keys = Object.getOwnPropertyNames(error);\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    if (key !== 'stack' && key !== 'message') {\n      delete error[key];\n    }\n  }\n\n  // replace stack before message for Node.js 0.10 and below\n  error.stack = obj.stack.replace(error.message, obj.message);\n  error.message = obj.message;\n  return error;\n}\n\n/**\r\n * Get the simple type checker.\r\n *\r\n * @param {string} type\r\n * @return {function}\r\n */\n\nfunction typeChecker(type) {\n  return function checkType(req) {\n    return Boolean(typeis(req, type));\n  };\n}","map":null,"metadata":{},"sourceType":"script"}