{"ast":null,"code":"/*!\r\n * content-type\r\n * Copyright(c) 2015 Douglas Christopher Wilson\r\n * MIT Licensed\r\n */\n\n'use strict';\n\n/**\r\n * RegExp to match *( \";\" parameter ) in RFC 7231 sec 3.1.1.1\r\n *\r\n * parameter     = token \"=\" ( token / quoted-string )\r\n * token         = 1*tchar\r\n * tchar         = \"!\" / \"#\" / \"$\" / \"%\" / \"&\" / \"'\" / \"*\"\r\n *               / \"+\" / \"-\" / \".\" / \"^\" / \"_\" / \"`\" / \"|\" / \"~\"\r\n *               / DIGIT / ALPHA\r\n *               ; any VCHAR, except delimiters\r\n * quoted-string = DQUOTE *( qdtext / quoted-pair ) DQUOTE\r\n * qdtext        = HTAB / SP / %x21 / %x23-5B / %x5D-7E / obs-text\r\n * obs-text      = %x80-FF\r\n * quoted-pair   = \"\\\" ( HTAB / SP / VCHAR / obs-text )\r\n */\nvar PARAM_REGEXP = /; *([!#$%&'*+.^_`|~0-9A-Za-z-]+) *= *(\"(?:[\\u000b\\u0020\\u0021\\u0023-\\u005b\\u005d-\\u007e\\u0080-\\u00ff]|\\\\[\\u000b\\u0020-\\u00ff])*\"|[!#$%&'*+.^_`|~0-9A-Za-z-]+) */g; // eslint-disable-line no-control-regex\nvar TEXT_REGEXP = /^[\\u000b\\u0020-\\u007e\\u0080-\\u00ff]+$/; // eslint-disable-line no-control-regex\nvar TOKEN_REGEXP = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;\n\n/**\r\n * RegExp to match quoted-pair in RFC 7230 sec 3.2.6\r\n *\r\n * quoted-pair = \"\\\" ( HTAB / SP / VCHAR / obs-text )\r\n * obs-text    = %x80-FF\r\n */\nvar QESC_REGEXP = /\\\\([\\u000b\\u0020-\\u00ff])/g; // eslint-disable-line no-control-regex\n\n/**\r\n * RegExp to match chars that must be quoted-pair in RFC 7230 sec 3.2.6\r\n */\nvar QUOTE_REGEXP = /([\\\\\"])/g;\n\n/**\r\n * RegExp to match type in RFC 7231 sec 3.1.1.1\r\n *\r\n * media-type = type \"/\" subtype\r\n * type       = token\r\n * subtype    = token\r\n */\nvar TYPE_REGEXP = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+\\/[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;\n\n/**\r\n * Module exports.\r\n * @public\r\n */\n\nexports.format = format;\nexports.parse = parse;\n\n/**\r\n * Format object to media type.\r\n *\r\n * @param {object} obj\r\n * @return {string}\r\n * @public\r\n */\n\nfunction format(obj) {\n  if (!obj || typeof obj !== 'object') {\n    throw new TypeError('argument obj is required');\n  }\n  var parameters = obj.parameters;\n  var type = obj.type;\n  if (!type || !TYPE_REGEXP.test(type)) {\n    throw new TypeError('invalid type');\n  }\n  var string = type;\n\n  // append parameters\n  if (parameters && typeof parameters === 'object') {\n    var param;\n    var params = Object.keys(parameters).sort();\n    for (var i = 0; i < params.length; i++) {\n      param = params[i];\n      if (!TOKEN_REGEXP.test(param)) {\n        throw new TypeError('invalid parameter name');\n      }\n      string += '; ' + param + '=' + qstring(parameters[param]);\n    }\n  }\n  return string;\n}\n\n/**\r\n * Parse media type to object.\r\n *\r\n * @param {string|object} string\r\n * @return {Object}\r\n * @public\r\n */\n\nfunction parse(string) {\n  if (!string) {\n    throw new TypeError('argument string is required');\n  }\n\n  // support req/res-like objects as argument\n  var header = typeof string === 'object' ? getcontenttype(string) : string;\n  if (typeof header !== 'string') {\n    throw new TypeError('argument string is required to be a string');\n  }\n  var index = header.indexOf(';');\n  var type = index !== -1 ? header.slice(0, index).trim() : header.trim();\n  if (!TYPE_REGEXP.test(type)) {\n    throw new TypeError('invalid media type');\n  }\n  var obj = new ContentType(type.toLowerCase());\n\n  // parse parameters\n  if (index !== -1) {\n    var key;\n    var match;\n    var value;\n    PARAM_REGEXP.lastIndex = index;\n    while (match = PARAM_REGEXP.exec(header)) {\n      if (match.index !== index) {\n        throw new TypeError('invalid parameter format');\n      }\n      index += match[0].length;\n      key = match[1].toLowerCase();\n      value = match[2];\n      if (value.charCodeAt(0) === 0x22 /* \" */) {\n        // remove quotes\n        value = value.slice(1, -1);\n\n        // remove escapes\n        if (value.indexOf('\\\\') !== -1) {\n          value = value.replace(QESC_REGEXP, '$1');\n        }\n      }\n      obj.parameters[key] = value;\n    }\n    if (index !== header.length) {\n      throw new TypeError('invalid parameter format');\n    }\n  }\n  return obj;\n}\n\n/**\r\n * Get content-type from req/res objects.\r\n *\r\n * @param {object}\r\n * @return {Object}\r\n * @private\r\n */\n\nfunction getcontenttype(obj) {\n  var header;\n  if (typeof obj.getHeader === 'function') {\n    // res-like\n    header = obj.getHeader('content-type');\n  } else if (typeof obj.headers === 'object') {\n    // req-like\n    header = obj.headers && obj.headers['content-type'];\n  }\n  if (typeof header !== 'string') {\n    throw new TypeError('content-type header is missing from object');\n  }\n  return header;\n}\n\n/**\r\n * Quote a string if necessary.\r\n *\r\n * @param {string} val\r\n * @return {string}\r\n * @private\r\n */\n\nfunction qstring(val) {\n  var str = String(val);\n\n  // no need to quote tokens\n  if (TOKEN_REGEXP.test(str)) {\n    return str;\n  }\n  if (str.length > 0 && !TEXT_REGEXP.test(str)) {\n    throw new TypeError('invalid parameter value');\n  }\n  return '\"' + str.replace(QUOTE_REGEXP, '\\\\$1') + '\"';\n}\n\n/**\r\n * Class to represent a content type.\r\n * @private\r\n */\nfunction ContentType(type) {\n  this.parameters = Object.create(null);\n  this.type = type;\n}","map":null,"metadata":{},"sourceType":"script"}